#! /usr/bin/python3
#
# Generator for stubs to call C functions from python

import sys

# parameter type map -- specifies the type of function parameters
type_map = {
    "I": "uint",
    "i": "int",
    "H": "uint16",
    "h": "int16",
    "B": "uint8",
    "b": "int8",
    "P": "void*",  # P: pointer, e.g. bytes, bytearray, anything supporting the buffer protocol
    "s": "char*",  # s: string
    "v": "void",  # v: void, can only be used as single parameter to indicate there are none
}

# return type map -- specifies the type of the function return value
return_map = {
    "I": "mp_obj_new_int({})",  # any form of single-word integer
    "s": "{0} ? mp_obj_new_str({0}, strlen({0})) : mp_const_none",  # string
    "v": "{}",
}

# files to import -- this list gets augmented with the files specified
imports = [
    "esp_err.h",
]

# functions for which to create stubs
entry_points = []

# sizeof constants to provide
sizeof = []

# ===== Parse stub sepcifications
for l in sys.stdin:
    l = l.strip()
    if l.startswith("i "):
        # "#import" filename
        fn = l[1:].strip()
        imports.append(fn)
    elif l.startswith("f "):
        # function template
        ll = l.split()
        if len(ll) != 4:
            print(
                "Cannot parse '{}', expected 'f <func name> <param types> <return type>'".format(
                    l
                ),
                file=sys.stderr,
            )
            continue
        entry_points.append((ll[1], ll[2], ll[3]))
    elif l.startswith("z "):
        # sizeof
        sizeof.append(l[1:].strip())
    elif l.startswith("#") or len(l) == 0:
        pass
    else:
        print("Cannot parse '{}'".format(l), file=sys.stderr)
print("Imports:", imports, file=sys.stderr)
print("Entry points:", entry_points, file=sys.stderr)

# ===== Generate espidf module to expose functions to python
builtin = False  # sys.argv[1] == '--builtin'
print("// This file has been automatically generated by genstub")
print("#include <assert.h>")
print("#include <string.h>")
if builtin:
    print('#include "py/runtime.h"')
else:
    print('#include "py/dynruntime.h"')

# Generate imports
print("// ESP-IDF imports")
for im in imports:
    print("#include <{}>".format(im))

# Generate function stubs
for name, args, res in entry_points:
    if args == "v":
        args = ""
    # function header
    print()
    print("STATIC mp_obj_t espidf_{}(".format(name), end="")
    if len(args) < 4:
        print(", ".join(["mp_obj_t arg{}".format(ix) for ix in range(len(args))]), end="")
    else:
        print("size_t n_args, const mp_obj_t *args", end="")
    print(") {")
    # convert MP object parameters to C values
    for ix, fmt in enumerate(args):
        if len(args) < 4:
            arg = "arg" + str(ix)
        else:
            arg = "args[" + str(ix) + "]"
        print("\t// convert", arg)
        if fmt in frozenset(["I", "i", "H", "h", "B", "b"]):
            # easy cases: some form of integer or single-word value
            print("\t{1} val{0} = ({1})mp_obj_get_int({2});".format(ix, type_map[fmt], arg))
        elif fmt == "s":
            # string, need to get data and length, then convert to null-terminated string
            print("\t{1} val{0} = mp_obj_str_get_str({2});".format(ix, type_map[fmt], arg))
        elif fmt == "P":
            # byte, bytearray or other buffer, need to get pointer to buffer
            print("\tvoid *val{0} = 0;".format(ix))
            print("\tif ({0} != mp_const_none) {{".format(arg))
            print("\t\tmp_buffer_info_t val{}_buf;".format(ix))
            print("\t\tmp_get_buffer_raise({1}, &val{0}_buf, MP_BUFFER_RW);".format(ix, arg))
            print("\t\tval{0} = (void *)(val{0}_buf.buf);".format(ix))
            print("\t}")
    # call the C function
    print("\t// call")
    if res == "v":
        # return type is void, i.e. no return value
        print("\tmp_obj_t ret = mp_const_none;")
        print("\t{}(".format(name), end="")
    else:
        # actual return type
        print("\tconst {} ret = {}(".format(type_map[res], name), end="")
    # argument list for call
    print(", ".join(["val{}".format(ix) for ix in range(len(args))]), end="")
    print(");")
    # finally return the return value...
    print("\treturn " + return_map[res].format("ret") + ";\n}")
    # produce the function object
    if len(args) < 4:
        print(
            "STATIC MP_DEFINE_CONST_FUN_OBJ_{}(espidf_{}_obj, espidf_{});".format(
                len(args), name, name
            )
        )
    else:
        print(
            "STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(espidf_{}_obj, {}, {}, espidf_{});".format(
                name, len(args), len(args), name
            )
        )
print()

# ===== Module definition
if builtin:
    # generate module built into the firmware
    print("STATIC const mp_rom_map_elem_t mp_module_espidf_globals_table[] = {")
    print("\t{ MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_espidf) },")
    for name, _, _ in entry_points:
        print("\t{{ MP_ROM_QSTR(MP_QSTR_{}), MP_ROM_PTR(&espidf_{}) }},".format(name, name))
    print(
        """\
};
STATIC MP_DEFINE_CONST_DICT(mp_module_espidf_globals, mp_module_espidf_globals_table);

const mp_obj_module_t mp_module_espidf = {
.base = { &mp_type_module },
.globals = (mp_obj_dict_t*)&mp_module_espidf_globals,
};

#endif
""",
        end="",
    )
else:
    # generate dynamically loadable module
    print("mp_obj_t mpy_init(mp_obj_fun_bc_t *self, size_t n_args, size_t n_kw, mp_obj_t *args) {")
    print("\tMP_DYNRUNTIME_INIT_ENTRY")
    for name, _, _ in entry_points:
        print("\tmp_store_global(MP_QSTR_{0}, MP_OBJ_FROM_PTR(&espidf_{0}_obj));".format(name))
    for name in sizeof:
        print("\tmp_store_global(MP_QSTR_{0}, mp_obj_new_int(sizeof({0})));".format(name))
    print("\tMP_DYNRUNTIME_INIT_EXIT")
    print("}")
